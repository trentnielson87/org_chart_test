<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Collapsible Org Chart - Full Working</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; margin:0; padding:0; }
  .node rect { fill: #fff; stroke: steelblue; stroke-width: 2px; rx: 6px; ry: 6px; }
  .node text { font: 12px sans-serif; pointer-events: none; }
  .node image { pointer-events: none; }
  .link { fill: none; stroke: #ccc; stroke-width: 2px; }
  svg { width: 100%; overflow: visible; display: block; }
  #controls { margin: 10px 20px; }
</style>
</head>
<body>
<div id="controls">
  <button id="toggleExpand">Toggle Expand All</button>
</div>
<h2 style="margin-left:20px;">Collapsible Org Chart - Full Working</h2>
<svg></svg>

<script>
const sheetId = "1xZAsHK_U8BajMe2d2pMEkSvQnrV2t7Ds08v_YeKgVAQ";
const url = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:json`;

const NODE_WIDTH = 140;
const NODE_HEIGHT = 50;
const VERTICAL_MARGIN = 80;
const MAX_PHOTO_SIZE = 60;

let allRoots = [];
let expandAll = false;

const svg = d3.select("svg");
const g = svg.append("g").attr("transform", "translate(80,40)");

fetch(url)
  .then(res => res.text())
  .then(text => {
    const json = JSON.parse(text.substring(text.indexOf("{"), text.lastIndexOf("}") + 1));
    const rows = json.table.rows;

    const data = rows.slice(1).map(r => ({
      manager: r.c[0]?.v?.toString().trim() ?? null,
      employee: r.c[1]?.v?.toString().trim() ?? null,
      title: r.c[2]?.v?.toString().trim() ?? "",
      photo: r.c[3]?.v?.toString().trim() ?? ""
    }));

    buildForest(data);
    drawForest();
  })
  .catch(err => console.error(err));

function buildForest(pairs) {
  const nodes = {};
  const childrenSet = new Set();

  // Create nodes
  pairs.forEach(({manager, employee, title, photo}) => {
    if(manager && !nodes[manager]) nodes[manager] = { name: manager, title:"", photo:"", children: [] };
    if(employee && !nodes[employee]) nodes[employee] = { name: employee, title, photo, children: [] };
    childrenSet.add(employee);
  });

  // Assign children
  pairs.forEach(({manager, employee}) => {
    if(manager && employee) nodes[manager].children.push(nodes[employee]);
  });

  // Identify roots (nodes never children)
  allRoots = Object.values(nodes).filter(n => !childrenSet.has(n.name));
}

function drawForest() {
  g.selectAll("*").remove();

  // Create a dummy root for disconnected nodes
  const dummyRoot = { name: "ROOT", children: allRoots };

  const tree = d3.tree().nodeSize([NODE_HEIGHT+60, NODE_WIDTH+60]);
  const root = d3.hierarchy(dummyRoot);

  if(!expandAll && root.children) root.children.forEach(collapse);

  // Collapse helper
  function collapse(d) {
    if(d.children){ d._children=d.children; d._children.forEach(collapse); d.children=null; }
  }

  // Truncate text
  function truncateText(str, maxWidth, fontSize = 12) {
    const ellipsis = "...";
    const approxCharWidth = fontSize * 0.6;
    const maxChars = Math.floor(maxWidth / approxCharWidth);
    if(str.length > maxChars) return str.slice(0, maxChars - ellipsis.length) + ellipsis;
    return str;
  }

  // Compute tree layout
  tree(root);

  // Compute total height for SVG
  const totalHeight = d3.max(root.descendants(), d => d.x) + NODE_HEIGHT;
  svg.attr("height", totalHeight + 80);

  // Draw links
  const link = g.selectAll(".link").data(root.links());
  link.enter().append("path")
    .attr("class","link")
    .merge(link)
    .attr("d", d => {
      const startX = d.source.y + NODE_WIDTH/2;
      const startY = d.source.x;
      const endX = d.target.y - NODE_WIDTH/2;
      const endY = d.target.x;
      return `M${startX},${startY} C${(startX+endX)/2},${startY} ${(startX+endX)/2},${endY} ${endX},${endY}`;
    });
  link.exit().remove();

  // Draw nodes
  const node = g.selectAll(".node").data(root.descendants());
  const nodeEnter = node.enter().append("g")
    .attr("class","node")
    .attr("transform", d=>`translate(${d.y},${d.x})`)
    .attr("title", d => `${d.data.name}${d.data.title ? ' - '+d.data.title : ''}`)
    .on("click", (event,d)=>{
      if(d.children){ d._children=d.children; d.children=null;} 
      else {d.children=d._children; d._children=null;} 
      drawForest();
    });

  nodeEnter.append("rect")
    .attr("width", NODE_WIDTH)
    .attr("height", NODE_HEIGHT)
    .attr("x",-NODE_WIDTH/2)
    .attr("y",-NODE_HEIGHT/2)
    .attr("fill","#fff")
    .attr("stroke","steelblue")
    .attr("stroke-width",2)
    .attr("rx",6)
    .attr("ry",6);

  nodeEnter.filter(d => d.data.photo)
    .append("image")
    .attr("xlink:href", d => d.data.photo)
    .attr("width", d => Math.min(MAX_PHOTO_SIZE, NODE_WIDTH*0.9))
    .attr("height", d => Math.min(MAX_PHOTO_SIZE, NODE_HEIGHT*1.8))
    .attr("x", d => -Math.min(MAX_PHOTO_SIZE, NODE_WIDTH*0.9)/2)
    .attr("y", d => -NODE_HEIGHT/2 - Math.min(MAX_PHOTO_SIZE, NODE_HEIGHT*1.8) - 5)
    .attr("clip-path","circle(50%)");

  nodeEnter.append("text")
    .attr("x",0).attr("y",-2)
    .attr("text-anchor","middle")
    .text(d => truncateText(d.data.name, NODE_WIDTH-10));

  nodeEnter.append("text")
    .attr("x",0).attr("y",14)
    .attr("text-anchor","middle")
    .attr("font-size","10px")
    .attr("fill","#555")
    .text(d => truncateText(d.data.title, NODE_WIDTH-10, 10));

  node.exit().remove();
}

// Toggle expand
document.getElementById("toggleExpand").addEventListener("click", () => {
  expandAll = !expandAll;
  drawForest();
});

// Redraw on resize
window.addEventListener("resize", () => {
  if(allRoots.length>0) drawForest();
});
</script>
</body>
</html>
